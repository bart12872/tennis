<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Stats Tennis</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 10px;
      max-width: 320px;
      margin: auto;
    }
    button {
      font-size: 1.2em;
      padding: 12px;
      margin: 4px;
      width: 90%;
    }
    #actions, #logs {
      display: none;
    }
    textarea {
      width: 100%;
      height: 200px;
      margin-top: 20px;
    }
    #scoreboard {
      font-size: 1.2em;
      margin: 10px 0;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>  
</head>
<body>
  <h3>Match de tennis</h3>
  <div id="scoreboard">J1 : 0 | J2 : 0</div>
  <button id="startBtn">ğŸ¾ DÃ©but de match</button>

  <div id="actions">

    <!-- Ligne 1 : Point gagnÃ© / Faute directe -->
<div style="display: flex; gap: 2px; margin-bottom: 0px;">
  <button onclick="logAction('point_gagnÃ©_faute_dir_adverse')" style="flex: 1;">Pt gagnÃ© faute dir adv</button>
  <button onclick="logAction('faute_directe')" style="flex: 1;">Faute directe</button>
</div>
<!-- Ligne 2 : Faute non directe / Changer serveur -->
<div style="display: flex; gap: 2px; margin-bottom: 0px;">
  <button onclick="logAction('point_gagnÃ©_coup_gagnant')" style="flex: 1;">Pt gagnÃ© (hors faute adv)</button>
  <button onclick="logAction('faute_non_directe')" style="flex: 1;">Faute non directe</button>
</div>   
<div style="display: flex; gap: 2px; margin-bottom: 0px;">
  <button onclick="logAction('1er_service_KO')">1er service KO</button>
  <button onclick="logAction('2eme_service_KO')">2Ã¨me service KO</button>
</div>     
<div style="display: flex; gap: 2px; margin-bottom: 6px;">
  <button onclick="changeServer()">Changer serveur</button>
</div>    
    
 <!--   <button onclick="logAction('1er_service_KO')">1er service KO</button>  -->
<!--   <button onclick="logAction('2eme_service_KO')">2Ã¨me service KO</button> -->
<!--    <button onclick="logAction('point_gagnÃ©')">Point gagnÃ©</button>       -->
<!--    <button onclick="logAction('faute_directe')">Point perdu (faute directe)</button>        -->
<!--    <button onclick="logAction('faute_non_directe')">Point perdu (faute non directe)</button>  -->
<!--    <button onclick="changeServer()">Changer serveur</button>   -->
    <button onclick="showLogs()">ğŸ“‹ Voir les donnÃ©es</button>
    <button onclick="copyToClipboardCSV()">ğŸ“‹ Copier les donnÃ©es</button>
    <button onclick="clearLogs()">ğŸ—‘ï¸ RÃ©initialiser</button>
    <button onclick="downloadMatchCSV()">â¬‡ï¸ TÃ©lÃ©charger</button>
    <button onclick="showCSV()">ğŸ“„ Afficher CSV</button>
    <button onclick="saveLogsAsImage()">ğŸ–¼ï¸ Sauver comme image</button>
     <canvas id="textImage" style="display: none;"></canvas>
 <!--  <button onclick="generateQRCode()">ğŸ“· QR Code</button> 
    <div id="qrcode" style="margin-top: 20px;"></div>   -->
  </div>

  <div id="logs">
    <h3>Historique</h3>
    <textarea id="logOutput" readonly></textarea>
  </div>

  <script>
    let matchId;
    let logs = [];
    let j1Points = 0;
    let j2Points = 0;
    let j1Temp = 0;
    let j2Temp = 0;
    let currentServer = "J1";
    let isSecondServe = false;

    // Sauvegarde complÃ¨te du match en cours dans localStorage
    function saveCurrentMatch() {
      localStorage.setItem('tennis_match_en_cours', JSON.stringify({
        matchId,
        logs,
        j1Points,
        j2Points,
        j1Temp,
        j2Temp,
        currentServer
      }));
      // Aussi sauvegarder les logs sous la clÃ© unique pour archives
      localStorage.setItem("tennis_match_" + matchId, JSON.stringify(logs));
    }

    // Charger un match en cours au chargement de la page (si existant)
    window.onload = () => {
      const saved = localStorage.getItem('tennis_match_en_cours');
      if (saved) {
        const savedData = JSON.parse(saved);
        matchId = savedData.matchId;
        logs = savedData.logs;
        j1Points = savedData.j1Points;
        j2Points = savedData.j2Points;
        j1Temp = savedData.j1Temp;
        j2Temp = savedData.j2Temp;
        currentServer = savedData.currentServer;

        document.getElementById("actions").style.display = "block";
        document.getElementById("startBtn").style.display = "none";
        updateScoreboard();
      }
    };

    // DÃ©but de match
    document.getElementById("startBtn").onclick = () => {
      logs = [];
      const now = new Date();
      const pad = n => n.toString().padStart(2, '0');
      matchId = "tennis_match_" + pad(now.getHours()) + pad(now.getMinutes()) + pad(now.getSeconds());
      j1Points = 0;
      j2Points = 0;
      j1Temp = 0;
      j2Temp = 0;
      currentServer = "J1";
      updateScoreboard();
      saveCurrentMatch();
      document.getElementById("actions").style.display = "block";
      document.getElementById("startBtn").style.display = "none";
      alert("Match commencÃ© !");
    };

    // Enregistrer une action
    function logAction(action) {
      const timestamp = new Date().toISOString();
      logs.push({ matchId, timestamp, action, server: currentServer });
      if (["point_gagnÃ©_faute_dir_adverse", "point_gagnÃ©_coup_gagnant"].includes(action)) {
        j1Points++;
        j1Temp++;
        isSecondServe = false;
      } else if (["faute_directe", "faute_non_directe", "2eme_service_KO"].includes(action)) {
        j2Points++;
        j2Temp++;
        isSecondServe = false;
      } else if (["1er_service_KO", "xxx_KO"].includes(action)) {
        isSecondServe = true;
      }
      updateScoreboard();
      saveCurrentMatch();
    }

    // Changement de serveur
    function changeServer() {
      currentServer = currentServer === "J1" ? "J2" : "J1";
      //alert(`Serveur maintenant : ${currentServer}`);
      j1Temp = 0;
      j2Temp = 0;
      updateScoreboard();
      saveCurrentMatch();
    }

    // Mise Ã  jour du scoreboard
    function updateScoreboard() {
      let j1Serve = "";
      let j2Serve = "";

  if (currentServer === "J1") {
    j1Serve = isSecondServe ? "âšªâšª " : "âšª ";
  } else if (currentServer === "J2") {
    j2Serve = isSecondServe ? "âšªâšª " : "âšª ";
  }
      document.getElementById("scoreboard").textContent =
        `${j1Serve}J1 : ${j1Points} (+${j1Temp}) | ${j2Serve}J2 : ${j2Points} (+${j2Temp})`;
    }

    // Afficher lâ€™historique
    function showLogs() {
      document.getElementById("logs").style.display = "block";
      document.getElementById("logOutput").value = JSON.stringify(logs, null, 2);
    }

    // RÃ©initialiser tout
    function clearLogs() {
      if (confirm("Supprimer les donnÃ©es du match en cours ?")) {
        localStorage.removeItem("tennis_match_" + matchId);
        localStorage.removeItem('tennis_match_en_cours');
        logs = [];
        j1Points = 0;
        j2Points = 0;
        j1Temp = 0;
        j2Temp = 0;
        currentServer = "J1";
        updateScoreboard();
        document.getElementById("logOutput").value = "";
        document.getElementById("logs").style.display = "none";
        document.getElementById("actions").style.display = "none";
        document.getElementById("startBtn").style.display = "block";
        alert("DonnÃ©es effacÃ©es.");
      }
    }

    function downloadMatch() {
  const blob = new Blob([JSON.stringify(logs, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = matchId + ".json";
  a.click();
  URL.revokeObjectURL(url);
   }

    function downloadMatchCSV() {
  const csv = logsToCSV4Final(logs); // Cette fonction doit transformer tes logs en CSV
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = matchId + ".csv"; // Nom du fichier
  a.click();
  URL.revokeObjectURL(url);
}

function generateQRCode() {
  const data = JSON.stringify(logs);
  document.getElementById("qrcode").innerHTML = ""; // reset
  QRCode.toCanvas(data, { width: 200 }, function (err, canvas) {
    if (err) {
      alert("Erreur QR code : " + err);
      return;
    }
    document.getElementById("qrcode").appendChild(canvas);
  });
}  
    function copyToClipboard() {
  const data = JSON.stringify(logs, null, 2);
  navigator.clipboard.writeText(data).then(() => {
    alert("DonnÃ©es copiÃ©es dans le presse-papiers !");
  }).catch(err => {
    alert("Erreur lors de la copie : " + err);
  });
}

    
function saveLogsAsImage() {
//  const text = JSON.stringify(logs, null, 2);
  const text = logsToCSV4Final(logs); // CSV gÃ©nÃ©rÃ© depuis logs
  const canvas = document.getElementById("textImage");
  const ctx = canvas.getContext("2d");

  const lines = text.split('\n');
  const lineHeight = 20;
  const width = 1600;
  const height = lines.length * lineHeight + 20;

  canvas.width = width;
  canvas.height = height;

  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, width, height);
  ctx.fillStyle = "black";
  ctx.font = "16px monospace";

  lines.forEach((line, i) => {
    ctx.fillText(line, 10, 20 + i * lineHeight);
  });

  // GÃ©nÃ©rer l'image PNG
  const img = canvas.toDataURL("image/png");

  // CrÃ©er un lien de tÃ©lÃ©chargement
  const a = document.createElement("a");
  a.href = img;
  a.download = matchId + ".png";
  a.click();
}


function saveLogsAsImageCSV() {
  const text = logsToCSV4Final(logs); // CSV gÃ©nÃ©rÃ© depuis logs
  const lines = text.split('\n');
  const lineHeight = 20;
  const padding = 10;

  // Mesure dynamique de la largeur maximale
  const canvas = document.getElementById("textImage");
  const ctx = canvas.getContext("2d");
  ctx.font = "14px monospace";
  const width = Math.max(...lines.map(line => ctx.measureText(line).width)) + padding * 2 + 60;
  const height = lines.length * lineHeight + padding * 2;

  // Configuration du canvas
  canvas.width = width;
  canvas.height = height;

  // Dessin fond + texte
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, width, height);
  ctx.fillStyle = "black";
  ctx.font = "14px monospace";

  lines.forEach((line, i) => {
    ctx.fillText(line, padding, padding + (i + 1) * lineHeight - 6);
  });

  // GÃ©nÃ©rer et tÃ©lÃ©charger l'image
  const img = canvas.toDataURL("image/png");
  const a = document.createElement("a");
  a.href = img;
  a.download = matchId + ".png";
  a.click();
}


    
function showCSV() {
  if (!logs.length) {
    alert("Aucun log Ã  convertir.");
    return;
  }
  const csv = logsToCSV3(logs);
  document.getElementById("logOutput").value = csv;
  document.getElementById("logs").style.display = "block";
}

    function logsToCSV(logs) {
  if (!logs.length) return "";

  // Extraire les en-tÃªtes Ã  partir des clÃ©s du premier objet
  const headers = Object.keys(logs[0]);
  
  // Construire le CSV
  const csvRows = [];

  // Ligne d'en-tÃªte
  csvRows.push(headers.join(","));

  // Lignes de donnÃ©es
  for (const log of logs) {
    const values = headers.map(header => {
      let val = log[header];
      // Ã‰chapper les guillemets et mettre entre guillemets si besoin
      if (typeof val === "string" && (val.includes(",") || val.includes('"') || val.includes("\n"))) {
        val = '"' + val.replace(/"/g, '""') + '"';
      }
      return val;
    });
    csvRows.push(values.join(","));
  }

  return csvRows.join("\n");
}

function logsToCSV2(logs) {
  if (!logs.length) return "";

  const headers = Object.keys(logs[0]).concat("score");
  const csvRows = [headers.join(",")];

  let j1 = 0, j2 = 0, j1Temp = 0, j2Temp = 0;

  for (const log of logs) {
    const action = log.action;
    if (action === "point_gagnÃ©") {
      j1++; j1Temp++;
    } else if (["faute_directe", "faute_non_directe", "2eme_service_KO"].includes(action)) {
      j2++; j2Temp++;
    }

    const score = `J1: ${j1} (+${j1Temp}) | J2: ${j2} (+${j2Temp})`;

    const values = Object.keys(log).map(k => {
      let val = log[k];
      if (typeof val === "string" && (val.includes(",") || val.includes('"') || val.includes("\n"))) {
        val = '"' + val.replace(/"/g, '""') + '"';
      }
      return val;
    });

    values.push(`"${score}"`);
    csvRows.push(values.join(","));
  }

  return csvRows.join("\n");
}
function logsToCSV3(logs) {
  if (!logs.length) return "";

  const headers = Object.keys(logs[0]).concat("score");
  const csvRows = [headers.join(",")];

  let sets = [[0, 0]]; // [J1, J2] par set
  let currentSet = 0;
  let jeux = [0, 0];
  let points = [0, 0];
  let advantage = null;
  let inTiebreak = false;

  let currentServer = logs[0]?.server || "J1";

  function getTennisPoint(p1, p2) {
    const labels = ["0", "15", "30", "40"];
    if (p1 >= 3 && p2 >= 3) {
      if (p1 === p2) return "40A";
      if (p1 > p2) return "AD";
      return "";
    }
    return labels[p1] || "AD";
  }

  function scoreToString() {
    if (inTiebreak) {
      return `Set ${currentSet + 1} : ${sets[currentSet][0]}-${sets[currentSet][1]}, TB ${points[0]}-${points[1]}`;
    } else {
      const p1 = getTennisPoint(points[0], points[1]);
      const p2 = getTennisPoint(points[1], points[0]);
      return `Set ${currentSet + 1} : ${sets[currentSet][0]}-${sets[currentSet][1]}, Jeu ${jeux[0]}-${jeux[1]}, Pts ${p1}-${p2}`;
    }
  }

  function winPoint(winner) {
    const loser = 1 - winner;

    if (inTiebreak) {
      points[winner]++;
      if ((points[winner] >= 7) && (points[winner] - points[loser] >= 2)) {
        // gagne le tie-break â†’ set
        sets[currentSet][winner]++;
        currentSet++;
        sets.push([0, 0]);
        jeux = [0, 0];
        inTiebreak = false;
      }
      return;
    }

    if (points[winner] < 3) {
      points[winner]++;
    } else if (points[winner] === 3) {
      if (points[loser] < 3) {
        // Gagne le jeu
        jeux[winner]++;
        points = [0, 0];
        advantage = null;
      } else if (points[loser] === 3) {
        if (advantage === winner) {
          // gagne le jeu
          jeux[winner]++;
          points = [0, 0];
          advantage = null;
        } else if (advantage === loser) {
          advantage = null; // retour Ã  Ã©galitÃ©
        } else {
          advantage = winner;
        }
      }
    }

    // VÃ©rifier jeu gagnÃ©
    if (points[0] === 0 && points[1] === 0) {
      // Jeu terminÃ©, vÃ©rifier set
      if (jeux[winner] >= 6 && (jeux[winner] - jeux[loser]) >= 2) {
        sets[currentSet][winner]++;
        currentSet++;
        sets.push([0, 0]);
        jeux = [0, 0];
      } else if (jeux[0] === 6 && jeux[1] === 6) {
        inTiebreak = true;
        points = [0, 0];
      }
    }
  }

  for (const log of logs) {
    const action = log.action;

    if (action === "point_gagnÃ©") {
      winPoint(0);
    } else if (["faute_directe", "faute_non_directe", "2eme_service_KO"].includes(action)) {
      winPoint(1);
    } else if (action === "change_server") {
      currentServer = currentServer === "J1" ? "J2" : "J1";
    }

    const score = scoreToString();

    const values = Object.keys(log).map(k => {
      let val = log[k];
      if (typeof val === "string" && (val.includes(",") || val.includes('"') || val.includes("\n"))) {
        val = '"' + val.replace(/"/g, '""') + '"';
      }
      return val;
    });

    values.push(`"${score}"`);
    csvRows.push(values.join(","));
  }

  return csvRows.join("\n");
}

    function copyToClipboardCSV() {
  const csv = logsToCSV4Final(logs);
  navigator.clipboard.writeText(csv).then(() => {
    alert("DonnÃ©es CSV copiÃ©es dans le presse-papiers !");
  }).catch(err => {
    alert("Erreur lors de la copie : " + err);
  });
}
function logsToCSV4Final(logs) {
  if (!logs.length) return "";

  const headers = Object.keys(logs[0]).concat("score_tennis", "score_cumul");
  const csvRows = [headers.join(";")];

  let sets = [[0, 0]];
  let currentSet = 0;
  let jeux = [0, 0];
  let points = [0, 0];
  let advantage = null;
  let inTiebreak = false;

  let currentServer = logs[0]?.server || "J1";

  let j1Total = 0;
  let j2Total = 0;
  let j1Temp = 0;
  let j2Temp = 0;

  function getTennisPoint(p1, p2) {
    const labels = ["0", "15", "30", "40"];
    if (p1 >= 3 && p2 >= 3) {
      if (p1 === p2) return "40A";
      if (p1 > p2) return "AD";
      return "";
    }
    return labels[p1] || "AD";
  }

  function scoreTennis() {
    if (inTiebreak) {
      //return `Set ${currentSet + 1} : ${sets[currentSet][0]}-${sets[currentSet][1]}, TB ${points[0]}-${points[1]}`;
      return ``;
    } else {
      const p1 = getTennisPoint(points[0], points[1]);
      const p2 = getTennisPoint(points[1], points[0]);
      //return `Set ${currentSet + 1} : ${sets[currentSet][0]}-${sets[currentSet][1]}, Jeu ${jeux[0]}-${jeux[1]}, Pts ${p1}-${p2}`;
      return ``;
    }
  }

  function winPoint(winner) {
    const loser = 1 - winner;

    if (winner === 0) {
      j1Total++; j1Temp++;
    } else {
      j2Total++; j2Temp++;
    }

    if (inTiebreak) {
      points[winner]++;
      if ((points[winner] >= 7) && (points[winner] - points[loser] >= 2)) {
        sets[currentSet][winner]++;
        currentSet++;
        sets.push([0, 0]);
        jeux = [0, 0];
        inTiebreak = false;
      }
      return;
    }

    if (points[winner] < 3) {
      points[winner]++;
    } else if (points[winner] === 3) {
      if (points[loser] < 3) {
        jeux[winner]++;
        points = [0, 0];
        advantage = null;
      } else if (points[loser] === 3) {
        if (advantage === winner) {
          jeux[winner]++;
          points = [0, 0];
          advantage = null;
        } else if (advantage === loser) {
          advantage = null;
        } else {
          advantage = winner;
        }
      }
    }

    if (points[0] === 0 && points[1] === 0) {
      if (jeux[winner] >= 6 && (jeux[winner] - jeux[loser]) >= 2) {
        sets[currentSet][winner]++;
        currentSet++;
        sets.push([0, 0]);
        jeux = [0, 0];
      } else if (jeux[0] === 6 && jeux[1] === 6) {
        inTiebreak = true;
        points = [0, 0];
      }
    }
  }

  for (const log of logs) {
    const action = log.action;

    if (["point_gagnÃ©_faute_dir_adverse", "point_gagnÃ©_coup_gagnant"].includes(action)) {
      winPoint(0);
    } else if (["faute_directe", "faute_non_directe", "2eme_service_KO"].includes(action)) {
      winPoint(1);
    } else if (action === "change_server") {
      currentServer = currentServer === "J1" ? "J2" : "J1";
    }

    const scoreT = scoreTennis();
    const scoreC = `J1: ${j1Total} (+${j1Temp}) | J2: ${j2Total} (+${j2Temp})`;

    const values = Object.keys(log).map(k => {
      let val = log[k];
      if (typeof val === "string" && (val.includes(";") || val.includes('"') || val.includes("\n"))) {
        val = '"' + val.replace(/"/g, '""') + '"';
      }
      return val;
    });

    //values.push(scoreT);
    //values.push(scoreC);
    csvRows.push(values.join(";"));
  }

  return csvRows.join("\n");
}


    
  </script>
</body>
</html>
